# 정확한 계산이 필요할 경우

## 문제발생

1. 계산식이 틀리지 않음
2. 소수 둘째 자리까지 나타내기 위해 double 형을 사용해서 계산
3. 상품의 할인율 표시에서 약간의 오차가 발생 (0.01% 차이)

## 문제원인

### 가. 부동소수점

컴퓨터의 2진수 체계를 기반으로 실수를 표현하려면 어떻게 해야할까? 컴퓨터는 수를 표현하는 방법으로 고정 소수점, 부동 소수점 두 가지 방식이 있다. 컴퓨터는 메모리 효율성을 위해 부동소수점 방식을 사용한다.

1. 고정 소수점 방식
 고정 소수점 방식은 정수부와 소수부를 고정으로 나누어 표시하는 방식이다.

 ![Fixed Point](https://github.com/user-attachments/assets/76b149af-80e1-4344-b80b-47e2616cc031)

장점으로 직관적이지만 잘못하면 메모리 낭비가 심할 수 있다. 2666.188을 표현할때 0.188을 표현하기 위해 16비트를 사용하게 된다.

2. 부동 소수점 방식
 부동 소수점 방식에는 기수부와 지수부로 나눈다. 지수부에는 소수점의 위치를 가리키는 제곱승이 들어가고 기수부에는 실제 실수 데이터 비트들이 들어간다. 소수점이 떠다닌다 라는 의미로, 실수형에서 표현할 수 있는 값 범위를 최대로 넓혀서 오차를 줄이기 위한 방식이다.

![Floating Point](https://github.com/user-attachments/assets/9092268c-b5c8-4fb6-b9d6-039a38c2b548)

 * 가수: 실수의 실제값을 표현
 * 지수: 가수의 어디쯤에 소수점이 있는지 나타냄

### 나. 소수점 -> 2진수 & 근사치

0.625를 이진수로 표현한다면

```plaintext
0.625 * 2 = 1.25 = 0.25 + 1
0.25 * 2  = 0.5 = 0.5 + 0
0.5 * 2 = 1.0 = 0.0 + 1
```

결과는 0.101

정확하게 값이 떨어지기도 하지만 무한히 반복하는 경우도 있다. 이때 표현범위의 한계 때문에 근사치를 구하게 된다. IEEE(전기전자공학자협회)의 공식문서를 보면([IEE754](https://iremi.univ-reunion.fr/IMG/pdf/ieee-754-2008.pdf)) 반올림되거나 오버플로된 결과를 반환하라고 한다.

문제가 발생한 원인은 근사치로 인한 약간의 오차가 발생하여 결과값이 다르게 나오게 된 것이다. 이를 해결하고자 Java에는 BigDecimal 클래스가 있다. 문제가 발생한 코드에는 BigDecimal 클래스를 사용하고 있기는 했지만 BigDecimal 인스턴스를 생성하기 전 생성자에 double형으로 계산하는 코드가 있었고 여기서 오차가 발생하여 BigDecimal 클래스를 사용했지만 약간의 오차가 발생했다.

```Java
BigDecimal a = BigDecimal.valueOf(doubleA - doubleB); // double형 a와 b를 뺀 값을 BigDecimal로 생성 => 오차 발생
BigDecimal b = BigDecimal.valueOf(...);

... // 기타 계산

// 결과값이 할인율 35%가 아닌 36%로 나옴
```
